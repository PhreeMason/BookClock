/**
 * Metadata Achievement Subscriber
 * A configurable achievement subscriber that uses metadata to define behavior
 */

import { useSupabase } from '@/lib/supabase';
import { getCalculator } from './AchievementCalculators';
import {
    AchievementConfig,
    AchievementEvent,
    AchievementProgress,
    AchievementSubscriber,
    EventType,
    PersistenceType
} from './types';

export class MetadataAchievementSubscriber implements AchievementSubscriber {
    public readonly achievementId: string;
    public readonly achievementName: string;
    public readonly subscribedEvents: EventType[];
    private readonly config: AchievementConfig;

    constructor(config: AchievementConfig) {
        this.config = config;
        this.achievementName = config.name;
        this.achievementId = config.id;
        this.subscribedEvents = config.subscribedEvents;
    }

    saveAchievementProgress = async (progress: AchievementProgress): Promise<void> => {
        const supabase = useSupabase();
        const { data, error } = await supabase
            .from('achievement_progress')
            .upsert({
                ...progress,
                achievement_id: this.achievementId,
            },
            { onConflict:'achievement_id,user_id', ignoreDuplicates: false } // Ensure we update existing records
        );

        if (error) {
            console.error(`Error saving achievement progress for ${this.achievementId}:`, error);
            throw error;
        }
    }

    /**
     * Handle an incoming event
     */
    async handleEvent(event: AchievementEvent, recordId: string): Promise<void> {
        // Only process events we're subscribed to
        if (!this.subscribedEvents.includes(event.type)) {
            return;
        }

        try {
            const newProgress = await this.checkCriteria(recordId);
            if (newProgress) {
                await this.saveAchievementProgress(newProgress);

                // Log achievement unlock if completed
                if (newProgress.current_value >= (newProgress.max_value || this.config.targetValue)) {
                    console.log(`ðŸŽ‰ Achievement unlocked: ${this.config.name}`);
                }
            }
        } catch (error) {
            console.error(`Error handling event for achievement ${this.achievementId}:`, error);
            // Don't rethrow - we want other achievements to continue processing
        }
    }

    /**
     * Check the current criteria and calculate progress
     */
    async checkCriteria(recordId: string): Promise<AchievementProgress> {
        try {
            // Get the calculator function
            const calculatorFunction = getCalculator(this.config.calculatorFunction);

            if (!calculatorFunction) {
                console.warn(`Calculator function ${this.config.calculatorFunction} not found for achievement ${this.achievementId}`);
                return this.createDefaultProgress();
            }

            // Calculate current value using the specified calculator with recordId
            const currentValue = await calculatorFunction(recordId, this.config);

            // Create progress object with required fields
            const progress: AchievementProgress = {
                achievement_id: this.achievementId,
                current_value: currentValue,
                max_value: this.config.targetValue,
                last_updated: new Date().toISOString(),
                updated_at: new Date().toISOString(),
                created_at: new Date().toISOString(),
                id: '', // Will be generated by DB
                metadata: null,
                user_id: '' // Will be set by saveAchievementProgress
            };

            return progress;
        } catch (error) {
            console.error(`Error calculating criteria for achievement ${this.achievementId}:`, error);
            return this.createDefaultProgress();
        }
    }

    /**
     * Determine if progress should be updated based on persistence strategy
     */
    private shouldUpdateProgress(
        existingProgress: AchievementProgress | null,
        newProgress: AchievementProgress
    ): boolean {
        if (!existingProgress) {
            return true; // Always update if no existing progress
        }

        switch (this.config.persistenceStrategy) {
            case PersistenceType.CUMULATIVE:
                // For cumulative achievements, only update if value increased or completion status changed
                const newCompleted = newProgress.current_value >= (newProgress.max_value || this.config.targetValue);
                const existingCompleted = existingProgress.current_value >= (existingProgress.max_value || this.config.targetValue);
                return newProgress.current_value > existingProgress.current_value ||
                    newCompleted !== existingCompleted;

            case PersistenceType.SNAPSHOT:
                // For snapshot achievements, always update with current state
                const newSnapshotCompleted = newProgress.current_value >= (newProgress.max_value || this.config.targetValue);
                const existingSnapshotCompleted = existingProgress.current_value >= (existingProgress.max_value || this.config.targetValue);
                return newProgress.current_value !== existingProgress.current_value ||
                    newSnapshotCompleted !== existingSnapshotCompleted;

            case PersistenceType.TEMPORAL:
                // For temporal achievements, always update (they can reset)
                return true;

            default:
                return true;
        }
    }

    /**
     * Create default progress when calculation fails
     */
    private createDefaultProgress(): AchievementProgress {
        return {
            achievement_id: this.achievementId,
            current_value: 0,
            max_value: this.config.targetValue,
            last_updated: new Date().toISOString(),
            updated_at: new Date().toISOString(),
            created_at: new Date().toISOString(),
            id: '', // Will be generated by DB
            metadata: null,
            user_id: '' // Will be set by saveAchievementProgress
        };
    }

    /**
     * Get achievement configuration
     */
    getConfig(): AchievementConfig {
        return { ...this.config };
    }

    /**
     * Check if this subscriber handles a specific event type
     */
    handlesEventType(eventType: EventType): boolean {
        return this.subscribedEvents.includes(eventType);
    }
}